# 第五层：实时系统层 (RTOS)

## 层级定位
实时系统层是LuatOS架构的底层基础，提供任务调度、内存管理、同步互斥、定时器等基础服务。这一层通常基于FreeRTOS等成熟的实时操作系统实现，为上层提供稳定可靠的运行环境。

## 主要职责

### 1. 任务调度管理
- 多任务并发执行
- 优先级调度算法
- 任务状态管理
- 中断处理

### 2. 内存管理
- 动态内存分配
- 内存池管理
- 内存保护机制
- 内存泄漏检测

### 3. 同步互斥
- 信号量机制
- 互斥锁
- 事件标志
- 消息队列

### 4. 定时器服务
- 硬件定时器抽象
- 软件定时器
- 延时服务
- 时间管理

## 核心代码分析

### 1. RTOS抽象层 - luat_rtos.h

```c
// 文件位置: luat/include/luat_rtos.h
// RTOS抽象层接口定义

// 任务句柄类型
typedef void * luat_rtos_task_handle;

// 任务入口函数类型
typedef void (*luat_rtos_task_entry) (void*);

// 任务创建接口
int luat_rtos_task_create(luat_rtos_task_handle *task_handle, 
                         uint32_t stack_size, 
                         uint8_t priority, 
                         const char *task_name, 
                         luat_rtos_task_entry task_fun, 
                         void* user_data, 
                         uint16_t event_cout) {
    // 参数验证
    if (task_handle == NULL || task_fun == NULL) {
        return -1;
    }
    
    // 创建FreeRTOS任务
    BaseType_t ret = xTaskCreate(
        (TaskFunction_t)task_fun,    // 任务函数
        task_name,                   // 任务名称
        stack_size / sizeof(StackType_t), // 栈大小(字)
        user_data,                   // 任务参数
        priority,                    // 优先级
        (TaskHandle_t*)task_handle   // 任务句柄
    );
    
    return (ret == pdPASS) ? 0 : -1;
}

// 任务删除接口
int luat_rtos_task_delete(luat_rtos_task_handle task_handle) {
    if (task_handle == NULL) {
        vTaskDelete(NULL); // 删除当前任务
    } else {
        vTaskDelete((TaskHandle_t)task_handle);
    }
    return 0;
}

// 任务休眠接口
void luat_rtos_task_sleep(uint32_t ms) {
    TickType_t ticks = pdMS_TO_TICKS(ms);
    if (ticks == 0) {
        ticks = 1; // 至少延时1个tick
    }
    vTaskDelay(ticks);
}

// 获取当前任务句柄
luat_rtos_task_handle luat_rtos_get_current_handle(void) {
    return (luat_rtos_task_handle)xTaskGetCurrentTaskHandle();
}

// 获取任务栈水位
uint32_t luat_rtos_task_get_high_water_mark(luat_rtos_task_handle task_handle) {
    TaskHandle_t handle = (TaskHandle_t)task_handle;
    if (handle == NULL) {
        handle = xTaskGetCurrentTaskHandle();
    }
    return uxTaskGetStackHighWaterMark(handle);
}
```

### 2. 信号量实现 - luat_rtos.h

```c
// 信号量句柄类型
typedef void * luat_rtos_semaphore_t;

// 信号量创建
int luat_rtos_semaphore_create(luat_rtos_semaphore_t *semaphore_handle, 
                              uint32_t init_count) {
    if (semaphore_handle == NULL) {
        return -1;
    }
    
    SemaphoreHandle_t sem;
    if (init_count <= 1) {
        // 二进制信号量
        sem = xSemaphoreCreateBinary();
        if (init_count == 1) {
            xSemaphoreGive(sem);
        }
    } else {
        // 计数信号量
        sem = xSemaphoreCreateCounting(init_count, init_count);
    }
    
    if (sem == NULL) {
        return -1;
    }
    
    *semaphore_handle = (luat_rtos_semaphore_t)sem;
    return 0;
}

// 信号量获取
int luat_rtos_semaphore_take(luat_rtos_semaphore_t semaphore_handle, 
                            uint32_t timeout) {
    if (semaphore_handle == NULL) {
        return -1;
    }
    
    TickType_t ticks = (timeout == LUAT_WAIT_FOREVER) ? 
                       portMAX_DELAY : pdMS_TO_TICKS(timeout);
    
    BaseType_t ret = xSemaphoreTake((SemaphoreHandle_t)semaphore_handle, ticks);
    return (ret == pdTRUE) ? 0 : -1;
}

// 信号量释放
int luat_rtos_semaphore_release(luat_rtos_semaphore_t semaphore_handle) {
    if (semaphore_handle == NULL) {
        return -1;
    }
    
    BaseType_t ret;
    if (xPortInISR()) {
        // 中断中释放
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        ret = xSemaphoreGiveFromISR((SemaphoreHandle_t)semaphore_handle, 
                                   &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    } else {
        // 任务中释放
        ret = xSemaphoreGive((SemaphoreHandle_t)semaphore_handle);
    }
    
    return (ret == pdTRUE) ? 0 : -1;
}
```

### 3. 互斥锁实现 - luat_rtos.h

```c
// 互斥锁句柄类型
typedef void * luat_rtos_mutex_t;

// 互斥锁创建
int luat_rtos_mutex_create(luat_rtos_mutex_t *mutex_handle) {
    if (mutex_handle == NULL) {
        return -1;
    }
    
    SemaphoreHandle_t mutex = xSemaphoreCreateMutex();
    if (mutex == NULL) {
        return -1;
    }
    
    *mutex_handle = (luat_rtos_mutex_t)mutex;
    return 0;
}

// 互斥锁加锁
int luat_rtos_mutex_lock(luat_rtos_mutex_t mutex_handle, uint32_t timeout) {
    if (mutex_handle == NULL) {
        return -1;
    }
    
    // 中断中不能使用互斥锁
    if (xPortInISR()) {
        return -1;
    }
    
    TickType_t ticks = (timeout == LUAT_WAIT_FOREVER) ? 
                       portMAX_DELAY : pdMS_TO_TICKS(timeout);
    
    BaseType_t ret = xSemaphoreTake((SemaphoreHandle_t)mutex_handle, ticks);
    return (ret == pdTRUE) ? 0 : -1;
}

// 互斥锁解锁
int luat_rtos_mutex_unlock(luat_rtos_mutex_t mutex_handle) {
    if (mutex_handle == NULL) {
        return -1;
    }
    
    // 中断中不能使用互斥锁
    if (xPortInISR()) {
        return -1;
    }
    
    BaseType_t ret = xSemaphoreGive((SemaphoreHandle_t)mutex_handle);
    return (ret == pdTRUE) ? 0 : -1;
}
```

### 4. 消息队列实现 - luat_rtos.h

```c
// 消息队列句柄类型
typedef void * luat_rtos_queue_t;

// 消息队列创建
int luat_rtos_queue_create(luat_rtos_queue_t *queue_handle, 
                          uint32_t item_count, 
                          uint32_t item_size) {
    if (queue_handle == NULL || item_count == 0 || item_size == 0) {
        return -1;
    }
    
    QueueHandle_t queue = xQueueCreate(item_count, item_size);
    if (queue == NULL) {
        return -1;
    }
    
    *queue_handle = (luat_rtos_queue_t)queue;
    return 0;
}

// 消息队列发送
int luat_rtos_queue_send(luat_rtos_queue_t queue_handle, 
                        void *item, 
                        uint32_t item_size, 
                        uint32_t timeout) {
    if (queue_handle == NULL || item == NULL) {
        return -1;
    }
    
    BaseType_t ret;
    if (xPortInISR()) {
        // 中断中发送
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        ret = xQueueSendFromISR((QueueHandle_t)queue_handle, 
                               item, 
                               &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    } else {
        // 任务中发送
        TickType_t ticks = (timeout == LUAT_WAIT_FOREVER) ? 
                           portMAX_DELAY : pdMS_TO_TICKS(timeout);
        ret = xQueueSend((QueueHandle_t)queue_handle, item, ticks);
    }
    
    return (ret == pdTRUE) ? 0 : -1;
}

// 消息队列接收
int luat_rtos_queue_recv(luat_rtos_queue_t queue_handle, 
                        void *item, 
                        uint32_t item_size, 
                        uint32_t timeout) {
    if (queue_handle == NULL || item == NULL) {
        return -1;
    }
    
    TickType_t ticks = (timeout == LUAT_WAIT_FOREVER) ? 
                       portMAX_DELAY : pdMS_TO_TICKS(timeout);
    
    BaseType_t ret = xQueueReceive((QueueHandle_t)queue_handle, item, ticks);
    return (ret == pdTRUE) ? 0 : -1;
}
```

### 5. 定时器实现 - luat_rtos.h

```c
// 定时器句柄类型
typedef void * luat_rtos_timer_t;

// 定时器回调函数类型
typedef LUAT_RT_RET_TYPE (*luat_rtos_timer_callback_t)(LUAT_RT_CB_PARAM);

// 定时器创建
int luat_rtos_timer_create(luat_rtos_timer_t *timer_handle) {
    if (timer_handle == NULL) {
        return -1;
    }
    
    // 创建软件定时器（不自动启动）
    TimerHandle_t timer = xTimerCreate(
        "LuatTimer",           // 定时器名称
        pdMS_TO_TICKS(1000),   // 初始周期（1秒）
        pdFALSE,               // 不自动重载
        NULL,                  // 定时器ID
        NULL                   // 回调函数（稍后设置）
    );
    
    if (timer == NULL) {
        return -1;
    }
    
    *timer_handle = (luat_rtos_timer_t)timer;
    return 0;
}

// 定时器启动
int luat_rtos_timer_start(luat_rtos_timer_t timer_handle, 
                         uint32_t timeout, 
                         uint8_t repeat, 
                         luat_rtos_timer_callback_t callback_fun, 
                         void *user_param) {
    if (timer_handle == NULL || callback_fun == NULL) {
        return -1;
    }
    
    TimerHandle_t timer = (TimerHandle_t)timer_handle;
    
    // 设置定时器参数
    vTimerSetTimerID(timer, user_param);
    
    // 修改定时器周期和重载模式
    TickType_t ticks = pdMS_TO_TICKS(timeout);
    if (ticks == 0) ticks = 1;
    
    BaseType_t ret = xTimerChangePeriod(timer, ticks, portMAX_DELAY);
    if (ret != pdPASS) {
        return -1;
    }
    
    // 设置重载模式
    if (repeat) {
        // 周期性定时器
        vTimerSetReloadMode(timer, pdTRUE);
    } else {
        // 一次性定时器
        vTimerSetReloadMode(timer, pdFALSE);
    }
    
    // 启动定时器
    ret = xTimerStart(timer, portMAX_DELAY);
    return (ret == pdPASS) ? 0 : -1;
}

// 定时器停止
int luat_rtos_timer_stop(luat_rtos_timer_t timer_handle) {
    if (timer_handle == NULL) {
        return -1;
    }
    
    BaseType_t ret = xTimerStop((TimerHandle_t)timer_handle, portMAX_DELAY);
    return (ret == pdPASS) ? 0 : -1;
}

// 定时器状态查询
int luat_rtos_timer_is_active(luat_rtos_timer_t timer_handle) {
    if (timer_handle == NULL) {
        return 0;
    }
    
    return xTimerIsTimerActive((TimerHandle_t)timer_handle) ? 1 : 0;
}
```

### 6. 临界区管理 - luat_rtos.h

```c
// 进入临界区
uint32_t luat_rtos_entry_critical(void) {
    if (xPortInISR()) {
        // 中断中使用中断屏蔽
        return portSET_INTERRUPT_MASK_FROM_ISR();
    } else {
        // 任务中使用调度器挂起
        taskENTER_CRITICAL();
        return 0;
    }
}

// 退出临界区
void luat_rtos_exit_critical(uint32_t critical) {
    if (xPortInISR()) {
        // 中断中恢复中断屏蔽
        portCLEAR_INTERRUPT_MASK_FROM_ISR(critical);
    } else {
        // 任务中恢复调度器
        taskEXIT_CRITICAL();
    }
}

// 获取中断状态
uint32_t luat_rtos_get_ipsr(void) {
    return __get_IPSR();
}
```

### 7. 事件标志组 - luat_rtos.h

```c
// 事件标志组句柄类型
typedef void * luat_rtos_flag_t;

// 事件标志组创建
int luat_rtos_flag_create(luat_rtos_flag_t *flag_handle) {
    if (flag_handle == NULL) {
        return -1;
    }
    
    EventGroupHandle_t event_group = xEventGroupCreate();
    if (event_group == NULL) {
        return -1;
    }
    
    *flag_handle = (luat_rtos_flag_t)event_group;
    return 0;
}

// 事件标志等待
int luat_rtos_flag_wait(luat_rtos_flag_t flag_handle, 
                       uint32_t mask, 
                       LUAT_FLAG_OP_E operation, 
                       uint32_t *flags, 
                       uint32_t timeout) {
    if (flag_handle == NULL) {
        return -1;
    }
    
    BaseType_t clear_on_exit = (operation == LUAT_FLAG_AND_CLEAR || 
                               operation == LUAT_FLAG_OR_CLEAR) ? pdTRUE : pdFALSE;
    BaseType_t wait_for_all = (operation == LUAT_FLAG_AND || 
                              operation == LUAT_FLAG_AND_CLEAR) ? pdTRUE : pdFALSE;
    
    TickType_t ticks = (timeout == LUAT_WAIT_FOREVER) ? 
                       portMAX_DELAY : pdMS_TO_TICKS(timeout);
    
    EventBits_t result = xEventGroupWaitBits(
        (EventGroupHandle_t)flag_handle,
        mask,
        clear_on_exit,
        wait_for_all,
        ticks
    );
    
    if (flags) {
        *flags = (uint32_t)result;
    }
    
    // 检查是否超时
    if ((result & mask) == 0) {
        return -1; // 超时
    }
    
    return 0;
}

// 事件标志设置
int luat_rtos_flag_release(luat_rtos_flag_t flag_handle, 
                          uint32_t mask, 
                          LUAT_FLAG_OP_E operation) {
    if (flag_handle == NULL) {
        return -1;
    }
    
    BaseType_t ret;
    if (xPortInISR()) {
        // 中断中设置
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        ret = xEventGroupSetBitsFromISR((EventGroupHandle_t)flag_handle, 
                                       mask, 
                                       &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    } else {
        // 任务中设置
        xEventGroupSetBits((EventGroupHandle_t)flag_handle, mask);
        ret = pdTRUE;
    }
    
    return (ret == pdTRUE) ? 0 : -1;
}
```

## FreeRTOS集成

### 1. FreeRTOS配置 - FreeRTOSConfig.h

```c
// 文件位置: components/freertos/include/FreeRTOSConfig.h
// FreeRTOS配置参数

#define configUSE_PREEMPTION                     1
#define configUSE_IDLE_HOOK                      0
#define configUSE_TICK_HOOK                      0
#define configCPU_CLOCK_HZ                       (SystemCoreClock)
#define configTICK_RATE_HZ                       ((TickType_t)1000)
#define configMAX_PRIORITIES                     (7)
#define configMINIMAL_STACK_SIZE                 ((uint16_t)128)
#define configTOTAL_HEAP_SIZE                    ((size_t)15360)
#define configMAX_TASK_NAME_LEN                  (16)
#define configUSE_TRACE_FACILITY                 1
#define configUSE_16_BIT_TICKS                   0
#define configIDLE_SHOULD_YIELD                  1
#define configUSE_MUTEXES                        1
#define configQUEUE_REGISTRY_SIZE                8
#define configCHECK_FOR_STACK_OVERFLOW           0
#define configUSE_RECURSIVE_MUTEXES              1
#define configUSE_MALLOC_FAILED_HOOK             0
#define configUSE_APPLICATION_TASK_TAG           0
#define configUSE_COUNTING_SEMAPHORES            1

// 软件定时器配置
#define configUSE_TIMERS                         1
#define configTIMER_TASK_PRIORITY                (2)
#define configTIMER_QUEUE_LENGTH                 10
#define configTIMER_TASK_STACK_DEPTH             (configMINIMAL_STACK_SIZE * 2)

// 协程配置
#define configUSE_CO_ROUTINES                    0
#define configMAX_CO_ROUTINE_PRIORITIES          (2)

// 内存分配配置
#define configSUPPORT_STATIC_ALLOCATION          0
#define configSUPPORT_DYNAMIC_ALLOCATION         1

// 中断优先级配置
#define configKERNEL_INTERRUPT_PRIORITY          255
#define configMAX_SYSCALL_INTERRUPT_PRIORITY     191

// API函数包含配置
#define INCLUDE_vTaskPrioritySet                 1
#define INCLUDE_uxTaskPriorityGet                1
#define INCLUDE_vTaskDelete                      1
#define INCLUDE_vTaskCleanUpResources            1
#define INCLUDE_vTaskSuspend                     1
#define INCLUDE_vTaskDelayUntil                  1
#define INCLUDE_vTaskDelay                       1
```

### 2. 内存管理适配

```c
// 文件位置: luat/freertos/luat_freertos_heap.c
// FreeRTOS内存管理适配

#include "FreeRTOS.h"
#include "task.h"
#include "luat_mem.h"

// LuatOS内存分配器
void* luat_heap_alloc(void *ud, void *ptr, size_t osize, size_t nsize) {
    (void)ud;
    (void)osize;
    
    if (nsize == 0) {
        // 释放内存
        if (ptr) {
            vPortFree(ptr);
        }
        return NULL;
    } else if (ptr == NULL) {
        // 分配新内存
        return pvPortMalloc(nsize);
    } else {
        // 重新分配内存
        void* new_ptr = pvPortMalloc(nsize);
        if (new_ptr) {
            size_t copy_size = (nsize < osize) ? nsize : osize;
            memcpy(new_ptr, ptr, copy_size);
            vPortFree(ptr);
        }
        return new_ptr;
    }
}

// 系统内存信息查询
void luat_meminfo_sys(size_t* total, size_t* used, size_t* max_used) {
    *total = configTOTAL_HEAP_SIZE;
    *used = configTOTAL_HEAP_SIZE - xPortGetFreeHeapSize();
    *max_used = configTOTAL_HEAP_SIZE - xPortGetMinimumEverFreeHeapSize();
}
```

### 3. 任务监控

```c
// 任务运行时间统计
void luat_rtos_task_run_time_record_enable(void) {
    // 启用任务运行时间统计
    #if (configGENERATE_RUN_TIME_STATS == 1)
    vTaskStartScheduler();
    #endif
}

// 打印任务运行时间
void luat_rtos_task_run_time_record_print(uint8_t print_ticks) {
    #if (configGENERATE_RUN_TIME_STATS == 1)
    char* buffer = pvPortMalloc(1024);
    if (buffer) {
        if (print_ticks) {
            vTaskGetRunTimeStats(buffer);
        } else {
            vTaskList(buffer);
        }
        printf("Task Stats:\n%s\n", buffer);
        vPortFree(buffer);
    }
    #endif
}
```

## 性能优化

### 1. 栈大小优化
```c
// 根据任务类型调整栈大小
#define LUAT_MAIN_TASK_STACK_SIZE    (4096)  // 主任务
#define LUAT_TIMER_TASK_STACK_SIZE   (1024)  // 定时器任务
#define LUAT_IDLE_TASK_STACK_SIZE    (512)   // 空闲任务
```

### 2. 优先级分配
```c
// 任务优先级分配策略
#define LUAT_TASK_PRIORITY_IDLE      (0)     // 空闲任务
#define LUAT_TASK_PRIORITY_LOW       (1)     // 低优先级任务
#define LUAT_TASK_PRIORITY_NORMAL    (3)     // 普通任务
#define LUAT_TASK_PRIORITY_HIGH      (5)     // 高优先级任务
#define LUAT_TASK_PRIORITY_CRITICAL  (6)     // 关键任务
```

### 3. 中断处理优化
```c
// 中断处理函数
void UART_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    
    // 处理中断
    if (UART_GetITStatus(UART1, UART_IT_RXNE)) {
        uint8_t data = UART_ReceiveData(UART1);
        
        // 发送到队列
        xQueueSendFromISR(uart_rx_queue, &data, &xHigherPriorityTaskWoken);
        
        UART_ClearITPendingBit(UART1, UART_IT_RXNE);
    }
    
    // 触发任务切换
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

实时系统层为LuatOS提供了稳定可靠的底层运行环境，通过抽象化的RTOS接口，使得LuatOS能够在不同的硬件平台和操作系统上运行，同时保证了系统的实时性和可靠性。 